defmodule Parser do

  def programa_parser(lista_tokens) when lista_tokens != [] do
    # IO.inspect(lista_tokens, label: "Entrada de parser")
    funcion = funcion_parser(lista_tokens)

    case funcion do
      {{:error, mensaje_error}, _rest} ->
        {:error, mensaje_error}

      {funcion_nodo, rest} ->          
        if rest == []  do
          %AST{node_name: :program, left_node: funcion_nodo}
        else
          {:error, "Error: Falla en los operandos"}
        end
    end
  end

  def funcion_parser([tupla_siguiente | rest]) do
    {_num, siguiente_token} = tupla_siguiente

    if siguiente_token == :pclave_int do
      [tupla_siguiente | rest] = rest
      {_num, siguiente_token} = tupla_siguiente

      if siguiente_token == :pclave_main do
        [tupla_siguiente | rest] = rest
        { num, siguiente_token} = tupla_siguiente

        if siguiente_token == :abre_paren do
          [tupla_siguiente | rest] = rest
          {_num, siguiente_token} = tupla_siguiente

          if siguiente_token == :cierra_paren do
            [tupla_siguiente | rest] = rest
            {_num, siguiente_token} = tupla_siguiente

            if siguiente_token == :abre_llave do
              analizador = analizador_gramatica(rest)

              case analizador do
                {{:error, _mensaje_error}, _rest} -> ##CHECAR BIEN CUANDO SE DEFINAN LOS ERRORES
                  # Tuvo que ser cambiado por las pruebas 
                {:error, "Linea: #{num}. Error: la funcion no devuelve nada"}

                {{:error, "Error: se esparaba ;"}} ->
                  {:error, "Linea: #{elem(tupla_siguiente,0)+1}. Error: Orden de operandos erroneos"}
                
                {:error, mensaje} ->
                  {:error, mensaje}

                {analizador_nodo, [tupla_siguiente | rest]} ->
                  {_num, siguiente_token} = tupla_siguiente

                  if siguiente_token == :cierra_llave do
                    {%AST{node_name: :funcion, value: :main, left_node: analizador_nodo}, rest}
                  else
                    {{:error, "Error: Se esperaba llave que cierra"}, rest}
                  end
              end
            else
              {:error, "Error: se esparaba llave que abriera"}
            end
          else
            {:error, "Linea: #{num}. Error: se esparaba parentesis que cerrara"}
          end
        else
          {:error, "Linea: #{num}. Error: se esparaba parentesis que abriera"}
        end
      else
        {:error, "Error: se esparaba funcion main"}
      end
    else
      {:error, "Linea: #{elem(siguiente_token,0)}. Error: la funcion no devuelve nada"}
    end
  end

  # Es el equivalente  parse_statement 
  def analizador_gramatica([tupla_siguiente | rest]) do
    {num, siguiente_token} = tupla_siguiente

    if siguiente_token == :pclave_return do
      expresion = analizador_expresion(rest)

      case expresion do
        {{:error, mensaje_error}, rest} ->
          {{:error, mensaje_error}, rest}

        {:error, mensaje}->
          {:error,mensaje}

        {exp_node, lista_final} ->
          [tupla_siguiente | rest] = lista_final
          {_num, siguiente_token} = tupla_siguiente

          # IO.inspect(lista_final, label: "Resto de regreso")

          if siguiente_token == :puntoycoma do
            {%AST{node_name: :return, left_node: exp_node}, rest}
          else
            {{:error, "Error: se esparaba ;"}}
          end
      end
    else
      {{:error, "Linea: #{num+1}. Error: se esperaba punto y coma."}}
    end
  end


  def peek_tokens(tokens) do

    case tokens do 
      []-> 
        {:error, "Faltan elementos"}
      _->
        [tupla_siguiente | _rest ] = tokens
         {_num, token} = tupla_siguiente 
         token
    end 
  end
 
  


 def crear_operador(nombre_nodo, hijo_left) do
    case hijo_left do
      {{:error, mensaje_error}, rest} ->
        {{:error, mensaje_error}, rest}

      {next_nodo, rest} ->
        {%AST{node_name: nombre_nodo, left_node: next_nodo}, rest}
    end
  end

  def get_operador_unario(siguiente_token) do
    case siguiente_token do
      :complemento ->
        {:complemento, :ok}

      :negacion ->
        {:negacion, :ok}

      :negacion_logica ->
        {:negacion_logica, :ok}

      _ ->
        {{:error, "Unario no valido"}, :mal}
    end
  end 
  
end 
