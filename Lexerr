defmodule Lexer do
  def clearesp (lista) do
    if lista != "int " and lista != "return " do
      lista=String.trim(lista)
      lista
    else
      lista
    end
  end

  def tokens({numRenglon,lista}) when lista != "" and lista != " " do
    lista = clearesp(lista)
    {token, ts} =
      case lista do
        "{" <> ts ->
          {:abre_llave, ts}

        "int " <> ts ->
          {:pclave_int, ts}

        "main" <> ts ->
          {:pclave_main, ts}

        "(" <> ts ->
          {:abre_paren, ts}

        ")" <> ts ->
          {:cierra_paren, ts}

        "return " <> ts ->
          {:pclave_return, ts}

        "-" <> ts ->
          {:negacion, ts}

        "~" <> ts ->
          {:complemento, ts}
	
        "!=" <> ts ->
          {:diferente_de, ts}

        _ -> 
          case Regex.run(~r/^\d+/, lista) do
            [value] -> {{:constante, String.to_integer(value)}, String.trim_leading(lista, value)}
            _ -> {:error_token, " "}
          end
      end
    
    ts = tokens({numRenglon,ts})
    [{numRenglon,token} | ts]
    
  end

  def tokens(_lista) do
    []
  end

  def flatmap([{numRenglon,cadena}]) do
    Enum.flat_map({numRenglon,cadena}, &tokens/1)
  end

  def lexer_principal(lista_principal, lista_tokens) do
    len_temp = length(lista_principal)
